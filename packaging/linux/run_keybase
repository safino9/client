#!/usr/bin/env bash

set -e -u -o pipefail

# This is the script responsible for launching keybase on boot on Linux. A
# .desktop file will be created by the service on first launch in
# ~/.config/autostart/ to invoke this script.

# NOTE: This logic is duplicated in systemd_linux.go. If you make changes here,
# keep them in sync.
systemd_running() {
    # First check that systemd is running at all at the system level. See
    # https://www.freedesktop.org/software/systemd/man/sd_booted.html.
    if ! [ -d "/run/systemd/system" ] ; then
        return 1
    fi

    # Check status of user manager as well, for systems that use systemd
    # but not the user manager (e.g., centos).
    # Ask the systemd user daemon for its status directly, to be sure
    # it's running. Note that "degraded" just means some service has failed to
    # start -- it could be anything, so we treat it the same as "running". (We
    # have to `|| true` to ignore non-zero exit status errors also for that
    # reason.)
    status="$(systemctl --user is-system-running || true)"
    if [ "$status" = "running" ] || [ "$status" = "degraded" ] ; then
        return 0
    elif [ -z "$status" ] ; then
        echo "WARNING: Couldn't reach the systemd user-level daemon."
        echo "Falling back to non-systemd startup."
        return 1
    else
        echo "WARNING: Systemd reported an unexpected status: $status"
        echo "Falling back to non-systemd startup."
        return 1
    fi
}

# Defaults to true unless KEYBASE_SYSTEMD=0.
wants_systemd() {
    [ "${KEYBASE_SYSTEMD:-1}" != "0" ] && systemd_running
}

write_startup_token() {
  echo "$1" > "$startup_token"
}

systemd_stop_if_active() {
    service="$1";
    if command -v systemctl &> /dev/null && systemctl --user is-active -q "$service"; then
        systemctl --user stop "$service"
    fi
}

# This works no matter how the services were started, because our
# Restart=on-failure systemd unit configuration won't restart after SIGTERM.
kill_all() {
  # systemd will restart services if they failed to stop, so do this explicitly
  # first to make the rest of a function a no-op
  if [ "$KEYBASE_KILL" = "1" ]; then
      systemd_stop_if_active "keybase"
      systemd_stop_if_active "kbfs"
      systemd_stop_if_active "keybase.gui"
      systemd_stop_if_active "keybase-redirector"
  fi

  killall Keybase &> /dev/null && echo Shutting down Keybase GUI...

  # mountdir may be empty on the initial install, so don't try to unmount in that case
  if mountdir="$(keybase config get --direct --bare mountdir 2> /dev/null)" && [ -n "$mountdir" ]; then
	  # Redundant in newer kbfsfuses, which catches SIGTERM and unmounts before exiting.
	  fusermount -uz "$mountdir" &> /dev/null && echo Unmounting "$mountdir"...
  fi

  killall kbfsfuse &> /dev/null && echo Unmounting and shutting down kbfsfuse...
  killall keybase &> /dev/null && echo Shutting down keybase service...

  # Only shut down redirector when stopping, but not for restarts.
  if [ "$KEYBASE_KILL" = "1" ]; then
      pkill -f keybase-redirector &> /dev/null && echo Shutting down keybase redirector...
  fi
}

echo_vars_by_name() {
    for var in "$@"; do
        ret="${!var:-}"
        if [ -n "$ret" ]; then
            printf "$var=%s\n" "$ret"
        fi
    done
}

gen_env() {
    # # This is for the system tray icon in new versions of Ubuntu that don't use Unity
    # # See https://github.com/electron/electron/issues/10887
    echo XDG_CURRENT_DESKTOP="Unity"

    # * This section is for the Keybase GUI
    # Some older distros (e.g. Ubuntu 16.04) don't make X session variables
    # available to user units automatically. Whitelisting them is safer than
    # dumping the entire environment, even though there's a chance we might
    # miss something, because some environment variables might contain
    # passwords or keys. Hopefully this section won't be needed someday.
    # (Arch Linux doesn't need it today.)
    # See: graphical-session.target.
    echo_vars_by_name "DISPLAY" "XAUTHORITY"

    # * This section is for the Keybase GUI
    # The following enable CJK and other alternative input methods
    # See https://github.com/keybase/client/issues/9861
    echo_vars_by_name "CLUTTER_IM_MODULE" "GTK_IM_MODULE" "QT_IM_MODULE" "QT4_IM_MODULE" "XMODIFIERS"

    # * This section is for the Keybase GUI
    # Arbitrary environment variables from bashrc and similar aren't
    # automatically available in the systemd session, and users probably
    # didn't use pam to define their XDG directories. Export them just in
    # case.
    echo_vars_by_name "XDG_DOWNLOAD_DIR"

    # # * This section is for the service, KBFS, and the Keybase GUI
    echo_vars_by_name "XDG_CACHE_HOME" "XDG_CONFIG_HOME" "XDG_DATA_HOME" "XDG_RUNTIME_DIR" "DBUS_SESSION_BUS_ADDRESS"
}

start_systemd() {
  echo Starting via systemd...

  # Reload possibly-updated unit files
  # This occurs in post-install, but only if it's actually packaged
  # and the user was already running Keybase.
  systemctl --user daemon-reload

  # We can't really use environment generators for this because...
  # If systemd version is before 233 (e.g., in Ubuntu 16.04 LTS), environment
  # generators are unsupported.
  # Also, by design, environment generators are not able to get user
  # environment variables which might be specified, e.g., in a interactive
  # shell file (rather than in say pam_environment). Thus, we always manually
  # create the environment file again. It should only be needed once during
  # every login to populate that file, after that, as long as they don't
  # change, systemctl will work without run_keybase. Work around by directly
  # creating an environment file that unit files read. If a user really
  # doesn't want to use run_keybase, they can specify their environment
  # variables in a more standard way and import $DISPLAY and $KEYBASE_AUTOSTART
  # into the user manager environment themselves, if the GUI is needed.
  # (graphical-session.target doesn't have great support either)
  # We don't do this *and* the environment generator because we don't want to
  # pollute the user manager environment with bad data.
  # If stable, user can pipe this to a local config file to remove this need.
  envfile="$runtime_dir/keybase.env"
  gen_env > "$envfile"

  # We don't want to persist this, so don't store it in the env file.
  # This is unset right after start in the unit file so subsequent direct
  # systemctl calls don't have it set.
  systemctl --user import-environment "KEYBASE_AUTOSTART"

  # The keybase.gui.service unit has keybase.service and kbfs.service as
  # dependencies, so we don't have to list them here. But including them lets
  # us report an error if they fail to start. Also prefer `restart` to `start`
  # so that we don't race against the service shutting down.
  # kbfs.service will attempt to start the redirector, but it isn't an error if
  # it fails to start, which happens if it is disabled.
  systemctl --user restart keybase.service kbfs.service
  [ "$KEYBASE_NO_GUI" == "1" ] || systemctl --user restart keybase.gui.service || echo "$gui_fail_help"
  write_startup_token "systemd"
}

run_redirector_in_background() {
  if ! keybase --use-root-config-file config get --direct --assert-false --assert-ok-on-nil disable-root-redirector &> /dev/null; then
    return 0
  fi
  redirector_log="$logdir/keybase.redirector.log"
  # An older version of post_install.sh could have made a redirector log
  # here that's owned by root.  If we can't write to it, then just nuke it
  # and overwrite.
  if [ -e "$redirector_log" ] && [ ! -w "$redirector_log" ]; then
    rm -f "$redirector_log"
  fi
  echo Mounting the file system...
  # We need nohup so the redirector doesn't terminate on shell exit,
  # but it isn't necessary for keybase/kbfs/gui which autofork.
  nohup keybase-redirector /keybase >> "$redirector_log" 2>&1 &
}

start_background() {
  echo Launching keybase service...
  # We set the --auto-forked flag here so that updated clients that try to
  # restart this service will know to re-fork it themselves. That's all it does.

  keybase --debug --use-default-log-file service --auto-forked &>> "$logdir/keybase.start.log" &

  run_redirector_in_background

  echo Starting KBFS...
  kbfsfuse -debug -log-to-file &>> "$logdir/keybase.start.log" &

  if [ "$KEYBASE_NO_GUI" != "1" ]; then
      # For system tray icon due to an upstream Electron issue:
      # https://github.com/electron/electron/issues/10887
      # Also exported in systemd keybase.gui unit explicitly
      export XDG_CURRENT_DESKTOP=Unity
      export KEYBASE_AUTOSTART="$KEYBASE_AUTOSTART"

      echo Launching Keybase GUI...
      gui_log="$logdir/Keybase.app.log"
      # Allow distributions to change the location of the gui as long as it's in PATH
      if command -v Keybase &> /dev/null; then
          Keybase &>> "$gui_log" &
      else
          /opt/keybase/Keybase &>> "$gui_log" &
      fi
  fi

  write_startup_token "background"
}

# Warn if the keybase binary path is unexpected, possibly due to a conflicting
# binary from the Node client. Can silence with KEYBASE_PATH_WARNING=0.
warn_if_weird_path() {
    if [ "${KEYBASE_PATH_WARNING:-}" = "0" ] ; then
        return
    fi
    if [ "$(command -v keybase)" != "/usr/bin/keybase" ] ; then
        echo "WARNING: Expected the keybase executable to be /usr/bin/keybase, but it's"
        echo "         $(command -v keybase) instead. Do you have multiple versions installed?"
        echo "         Export KEYBASE_PATH_WARNING=0 to silence this warning."
    fi
}

show_cryptosquirrel() {
  # Magical squirrel produced by https://github.com/erkin/ponysay
  if [ "${KEYBASE_NO_SQUIRREL:-}" != "1" ]; then
    cat /opt/keybase/crypto_squirrel.txt
  fi
}

init() {
  logdir="${XDG_CACHE_HOME:-$HOME/.cache}/keybase"
  mkdir -p "$logdir"
  runtime_dir="${XDG_RUNTIME_DIR:-$HOME/.config}/keybase"
  mkdir -p "$runtime_dir"
  startup_token="$runtime_dir/startup_mode"
  gui_fail_help="Failed to launch GUI. Pass -g to prevent startup if on a machine without a graphical display."
}

startup_all() {
  # There is a race condition where if we try to start the keybase service before
  # the previous process has died, we might fail to lock the pid file and error
  # out. Avoid this by waiting for the lock file to be free, on systems with flock
  # installed.
  lockfile="$runtime_dir/keybased.pid"
  if command -v flock &> /dev/null && [ -e "$lockfile" ] ; then
    flock "$lockfile" true
  fi

  warn_if_weird_path

  # Always stop any running services. With systemd, we could've decided to just
  # `start` services and no-op if they're already running, however:
  # 1) We still need to handle the case where services started outside systemd
  #    are currently running, and making that totally reliable is tricky.
  # 2) Users have come to expect that run_keybase will restart everything, and
  #    we tell them to do it after updates.
  kill_all

  if wants_systemd ; then
      start_systemd
  else
      start_background
  fi

  echo 'run_keybase: Success!'

  show_cryptosquirrel
}

usage_1="Usage: run_keybase [-hgake]. Starts the Keybase service, KBFS, and the GUI."
usage_2="Passing -h prints this help text."
usage_3="Passing -g, or the environment variable KEYBASE_NO_GUI=1, causes the script to not start the gui."
usage_4="Passing -a, or the environment variable KEYBASE_AUTOSTART=1, causes the GUI to stay minimized in system tray after startup."
usage_5="Passing -k, or the environment variable KEYBASE_KILL=1, causes all Keybase services to shut down."
usage_6="Passing -e prints the environment variables that would used by the systemd unit."
usage() {
    printf "%s\n%s\n%s\n%s\n%s\n%s\n" "$usage_1" "$usage_2" "$usage_3" "$usage_4" "$usage_5" "$usage_6";
}

KEYBASE_NO_GUI="${KEYBASE_NO_GUI:-0}"
KEYBASE_AUTOSTART="${KEYBASE_AUTOSTART:-0}"
KEYBASE_KILL="${KEYBASE_KILL:-0}"
while getopts "hgake" flag; do
    case $flag in
        g) KEYBASE_NO_GUI=1;;
        a) KEYBASE_AUTOSTART=1;;
        k) KEYBASE_KILL=1;;
        e) gen_env; exit 0;;
        h) usage; exit 0;;
        ?) usage; exit 1;;
    esac
done

init
kill_all
if [ "$KEYBASE_KILL" = "0" ]; then
    startup_all
fi
